<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Prevent, to some degree, the execution of inline JavaScript, as well as blocking all plugin content  -->
		<meta http-equiv="Content-Security-Policy" content="script-src 'none'; object-src 'none'; img-src 'none'; font-src 'none'; media-src 'none'; worker-src 'none'; connect-src 'none'; style-src 'self' ">
		<title>Porting a cross-platform GUI application to Rust</title>
		<link rel="icon" href="favicon.png" />
		<link rel="stylesheet" href="/a11y-dark.css">
		<link rel="stylesheet" href="/style.css">
	</head>
	<body>
		<main>
		<a target="_blank" rel="noreferrer" href="https://hacks.mozilla.org/2024/04/porting-a-cross-platform-gui-application-to-rust/">Go to article URL</a>
		<div id="content"><p></p><p>Firefox’s crash reporter is hopefully not something that most users experience often. However, it is still a very important component of Firefox, as it is integral in providing insight into the most visible bugs: those which crash the main process. These bugs offer the worst user experience (since the entire application must close), so fixing them is a very high priority. Other types of crashes, such as content (tab) crashes, can be handled by the browser and reported gracefully, sometimes without the user being aware that an issue occurred at all. But when the main browser process comes to a halt, we need another separate application to gather information about the crash and interact with the user.</p>
<p>This post details the approach we have taken to rewrite the crash reporter in Rust. We discuss the reasoning behind this rewrite, what makes the crash reporter a unique application, the architecture we used, and some details of the implementation.</p>
<h2>Why Rewrite?</h2>
<p>Even though it is important to properly handle main process crashes, the crash reporter hasn’t received significant development in a while (aside from development to ensure that crash reports and telemetry continue to reliably be delivered)! It has long been stuck in a local maximum of “good enough” and “scary to maintain”: it features 3 individual GUI implementations (for Windows, GTK+ for Linux, and macOS), glue code abstracting a few things (mostly in C++, and Objective-C for macOS), a binary blob produced by obsoleted Apple development tools, and no test suite. Because of this, there is a backlog of features and improvements which haven’t been acted on.</p>
<p>We’ve recently had a number of successful pushes to decrease crash rates (including both <a href="https://hacks.mozilla.org/2022/11/improving-firefox-stability-with-this-one-weird-trick/" rel="noreferrer" target="_blank">big leaps</a> and many small bug fixes), and the crash reporter has functioned well enough for our needs during this time. However, we’ve reached an inflection point where improving the crash reporter would provide valuable insight to enable us to decrease the crash rate even further. For the reasons previously mentioned, improving the current codebase is difficult and error-prone, so we deemed it appropriate to rewrite the application so we can more easily act on the feature backlog and improve crash reports.</p>
<p>Like many components of Firefox, we decided to use Rust for this rewrite to produce a more reliable and maintainable program. Besides the often-touted memory safety built into Rust, its type system and standard library make reasoning about code, handling errors, and developing cross-platform applications far more robust and comprehensive.</p>
<h2>Crash Reporting is an Edge Case</h2>
<p>There are a number of features of the crash reporter which make it quite unique, especially compared to other components which have been ported to Rust. For one thing, it is a standalone, individual program; basically no other components of Firefox are used in this way. Firefox itself launches many processes as a means of sandboxing and insulating against crashes, however these processes all talk to one another and have access to the same code base.</p>
<p>The crash reporter has a very unique requirement: it must use as <i>little as possible </i>of the Firefox code base, ideally none! We don’t want it to rely on code which may be buggy and cause the reporter itself to crash. Using a completely independent implementation ensures that when a main process crash does occur, the cause of that crash won’t affect the reporter’s functionality as well.</p>
<p>The crash reporter also necessarily has a GUI. This alone may not separate it from other Firefox components, but we can’t leverage any of the cross-platform rendering goodness that Firefox provides! So we need to implement a cross-platform GUI independent of Firefox as well. You might think we could reach for an existing cross-platform GUI crate, however we have a few reasons not to do so.</p>
<ul>
<li aria-level="1">We want to minimize the use of external code: to improve crash reporter reliability (which is paramount), we want it to be as simple and auditable as possible.</li>
<li aria-level="1">Firefox vendors all dependencies in-tree, so we are hesitant to bring in large dependencies (GUI libraries are likely pretty sizable).</li>
<li aria-level="1">There are only a few third-party crates that provide a native OS look and feel (or actually <i>use</i> native GUI APIs): it’s desirable for the crash reporter to have a native feel to be familiar to users and take advantage of accessibility features.</li>
</ul>
<p>So all of this is to say that third-party cross-platform GUI libraries aren’t a favorable option.</p>
<p>These requirements significantly narrow the approach that can be used.</p>
<h2>Building a GUI View Abstraction</h2>
<p>In order to make the crash reporter more maintainable (and make it easier to add new features in the future), we want to have as minimal and generic platform-specific code as possible. We can achieve this by using a simple UI model that can be converted into native GUI code for each platform. Each UI implementation will need to provide two methods (over arbitrary platform-specific <tt>&amp;self</tt> data):</p>
<pre><code class="language-rust">/// Run a UI loop, displaying all windows of the application until it terminates.
fn run_loop(&amp;self, app: model::Application)

/// Invoke a function asynchronously on the UI loop thread.
fn invoke(&amp;self, f: model::InvokeFn)
</code></pre>
<p>The <tt>run_loop</tt> function is pretty self-explanatory: the UI implementation takes an <tt>Application</tt> model (which we’ll discuss shortly) and runs the application, <i>blocking</i> until the application is complete. Conveniently, our target platforms generally have similar assumptions around threading: the UI runs in a single thread and typically runs an event loop which blocks on new events until an event signaling the end of the application is received.</p>
<p>There are some cases where we’ll need to run a function on the UI thread asynchronously (like displaying a window, updating a text field, etc). Since <tt>run_loop</tt> blocks, we need the <tt>invoke</tt> method to define how to do this. This threading model will make it easy to use the platform GUI frameworks: everything calling native functions will occur on a single thread (the main thread in fact) for the duration of the program.</p>
<p>This is a good time to be a bit more specific about exactly what each UI implementation will look like. We’ll discuss pain points for each later on. There are 4 UI implementations:</p>
<ul>
<li aria-level="1">A Windows implementation using the Win32 API.</li>
<li aria-level="1">A macOS implementation using Cocoa (AppKit and Foundation frameworks).</li>
<li aria-level="1">A Linux implementation using GTK+ 3 (the “+” has since been dropped in GTK 4, so henceforth I’ll refer to it as “GTK”). Linux doesn’t provide its own GUI primitives, and we already ship GTK with Firefox on Linux to make a modern-feeling GUI, so we can use it for the crash reporter, too. Note that some platforms that aren’t directly supported by Mozilla (like BSDs) use the GTK implementation as well.</li>
<li aria-level="1">A testing implementation which will allow tests to hook into a virtual UI and poke things (to simulate interactions and read state).</li>
</ul>
<p>One last detail before we dive in: the crash reporter (at least right now) has a pretty simple GUI. Because of this, an explicit <b>non-goal</b> of the development was to create a separate Rust GUI crate. We wanted to create just enough of an abstraction to cover the cases we needed in the crash reporter. If we need more controls in the future, we can add them to the abstraction, but we avoided spending extra cycles to fill out every GUI use case.</p>
<p>Likewise, we tried to avoid unnecessary development by allowing some tolerance for hacks and built-in edge cases. For example, our model defines a <tt>Button</tt> as an element which contains an arbitrary element, but actually supporting that with Win32 or AppKit would have required a lot of custom code, so we special case on a <tt>Button</tt> containing a <tt>Label</tt> (which is all we need right now, and an easy primitive available to us). I’m happy to say there aren’t really <i>many</i> special cases like that at all, but we are comfortable with the few that were needed.</p>
<h3>The UI Model</h3>
<p>Our model is a declarative structuring of concepts mostly present in GTK. Since GTK is a mature library with proven high-level UI concepts, this made it appropriate for our abstraction and made the GTK implementation pretty simple. For instance, the simplest way that GTK does layout (using container GUI elements and per-element margins/alignments) is good enough for our GUI, so we use similar definitions in the model. Notably, this “simple” layout definition is actually somewhat high-level and complicates the macOS and Windows implementations a bit (but this tradeoff is worth the ease of creating UI models).</p>
<p>The top-level type of our UI model is <tt>Application</tt>. This is pretty simple: we define an <tt>Application</tt> as a set of top-level <tt>Window</tt>s (though our application only has one) and whether the current locale is <a href="https://en.wikipedia.org/wiki/Right-to-left_script" rel="noreferrer" target="_blank">right-to-left</a>. We inspect Firefox resources to use the same locale that Firefox would, so we don’t rely on the native GUI’s locale settings.</p>
<p>As you might expect, each <tt>Window</tt> contains a single root element. The rest of the model is made up of a handful of typical container and primitive GUI elements:</p>
<p></p>
<p>The crash reporter only needs 8 types of GUI elements! And really, <tt>Progress</tt> is used as a spinner rather than indicating any real progress as of right now, so it’s not strictly necessary (but nice to show).</p>
<p>Rust does not explicitly support the object-oriented concept of inheritance, so you might be wondering how each GUI element “extends” <tt>Element</tt>. The relationship represented in the picture is somewhat abstract; the implemented <tt>Element</tt> looks like:</p>
<pre><code class="language-rust">pub struct Element {
    pub style: ElementStyle,
    pub element_type: ElementType
}
</code></pre>
<p>where <tt>ElementStyle</tt> contains all the common properties of elements (alignment, size, margin, visibility, and enabled state), and <tt>ElementType</tt> is an <tt>enum</tt> containing each of the specific GUI elements as variants.</p>
<h4>Building the Model</h4>
<p>The model elements are all intended to be consumed by the UI implementations; as such, almost all of the fields have public visibility. However, as a means of having a separate interface for <i>building</i> elements, we define an <tt>ElementBuilder&lt;T&gt;</tt> type. This type has methods that maintain assertions and provide convenience setters. For instance, many methods accept parameters that are <tt>impl Into&lt;MemberType&gt;</tt>, some methods like <tt>margin()</tt> set multiple values (but you can be more specific with <tt>margin_top()</tt>), etc.</p>
<p>There is a general <tt>impl&lt;T&gt; ElementBuilder&lt;T&gt;</tt> which provides setters for the various <tt>ElementStyle</tt> properties, and then each specific element type can also provide their own <tt>impl ElementBuilder&lt;SpecificElement&gt;</tt> with additional properties unique to the element type.</p>
<p>We combine <tt>ElementBuilder&lt;T&gt;</tt> with the final piece of the puzzle: a <tt>ui!</tt> macro. This macro allows us to write our UI in a declarative manner. For example, it allows us to write:</p>
<pre><code class="language-rust">let details_window = ui! {
    Window title("Crash Details") visible(show_details) modal(true) hsize(600) vsize(400)
         halign(Alignment::Fill) valign(Alignment::Fill)
    {
         VBox margin(10) spacing(10) halign(Alignment::Fill) valign(Alignment::Fill) {
            	Scroll halign(Alignment::Fill) valign(Alignment::Fill) {
                	TextBox content(details) halign(Alignment::Fill) valign(Alignment::Fill)
            	},
            	Button halign(Alignment::End) on_click(move || *show_details.borrow_mut() = false)
             {
                 Label text("Ok")
             }
         }
     }
};
</code></pre>
<p>The implementation of <tt>ui!</tt> is fairly simple. The first identifier provides the element type and an <tt>ElementBuilder&lt;T&gt;</tt> is created. After that, the remaining method-call-like syntax forms are called on the builder (which is mutable).</p>
<p>Optionally, a final set of curly braces indicate that the element has children. In that case, the macro is recursively called to create them, and <tt>add_child</tt> is called on the builder with the result (so we just need to make sure a builder has an <tt>add_child</tt> method). Ultimately the syntax transformation is pretty simple, but I believe that this macro is a little bit more than <i>just</i> syntax sugar: it makes reading and editing the UI a fair bit clearer, since the hierarchy of elements is represented in the syntax. Unfortunately a downside is that there’s no way to support automatic formatting of such macro DSLs, so developers will need to maintain a sane formatting.</p>
<p>So now we have a model defined and a declarative way of building it. But we haven’t discussed any dynamic runtime behaviors here. In the above example, we see an <tt>on_click</tt> handler being set on a <tt>Button</tt>. We also see things like the <tt>Window</tt>’s <tt>visible</tt> property being set to a <tt>show_details</tt> value which is changed when <tt>on_click</tt> is pressed. We hook into this declarative UI to change or react to events at runtime using a set of simple data binding primitives with which UI implementations can interact.</p>
<div>
<p><i>Many</i> GUI frameworks nowadays (both for Rust and other languages) have been built with the “diffing element trees” architecture (think <a href="https://react.dev/" rel="noreferrer" target="_blank">React</a>), where your code is (at least mostly) functional and side-effect-free and produces the GUI view as a function of the current state. This approach has its tradeoffs: for instance, it makes complicated, stateful alterations of the layout very simple to write, understand, and maintain, and encourages a clean separation of model and view! However since we <i>aren’t</i> writing a framework, and our application is and will remain fairly simple, the benefits of such an architecture were not worth the additional development burden. Our implementation is more similar to the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noreferrer" target="_blank">MVVM architecture</a>:</p>
<ul>
<li aria-level="1">the model is, well, the model discussed here;</li>
<li aria-level="1">the views are the various UI implementations; and</li>
<li aria-level="1">the viewmodel is (loosely, if you squint) the collection of data bindings.</li>
</ul>
</div>
<h3>Data Binding</h3>
<p>There are a few types which we use to declare dynamic (runtime-changeable) values. In our UI, we needed to support a few different behaviors:</p>
<ul>
<li aria-level="1">triggering <b>events</b>, i.e., what happens when a button is clicked,</li>
<li aria-level="1"><b>synchronized</b> values which will mirror and notify of changes to all clones, and</li>
<li aria-level="1"><b>on-demand</b> values which can be queried for the current value.</li>
</ul>
<div>
<p>On-demand values are used to get textbox contents rather than using a synchronized value, in an effort to avoid implementing debouncing in each UI. It may not be terribly difficult to do so, but it also wasn’t difficult to support the on-demand implementation.</p>
</div>
<p>As a means of convenience, we created a <tt>Property</tt> type which encompasses the value-oriented fields as well. A <tt>Property&lt;T&gt;</tt> can be set to either a static value (<tt>T</tt>), a synchronized value (<tt>Synchronized&lt;T&gt;</tt>), or an on-demand value (<tt>OnDemand&lt;T&gt;</tt>). It supports an <tt>impl From</tt> for each of these, so that builder methods can look like <tt>fn my_method(&amp;mut self, value: impl Into&lt;Property&lt;T&gt;&gt;)</tt> allowing any supported value to be passed in a UI declaration.</p>
<p>We won’t discuss the implementation in depth (<a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/data.rs" rel="noreferrer" target="_blank">it’s what you’d expect</a>), but it’s worth noting that these are all <tt>Clone</tt> to easily share the data bindings: they use <tt>Rc</tt> (we don’t need thread safety) and <tt>RefCell</tt> as necessary to access callbacks.</p>
<p>In the example from the last section, <tt>show_details</tt> is a <tt>Synchronized&lt;bool&gt;</tt> value. When it changes, the UI implementations change the associated window visibility. The <tt>Button</tt> <tt>on_click</tt> callback sets the synchronized value to false, hiding the window (note that the details window used in this example is never closed, it is just shown and hidden).</p>
<div>
<p>In a former iteration, data binding types had a lifetime parameter which specified the lifetime for which event callbacks were valid. While we were able to make this work, it greatly complicated the code, especially because there’s no way to communicate the correct covariance of the lifetime to the compiler, so there was additional <tt>unsafe</tt> code transmuting lifetimes (though it was contained as an implementation detail). These lifetimes were also infectious, requiring some of the complicated semantics regarding their safety to be propagated into the model types which stored <tt>Property</tt> fields.</p>
<p>Much of this was to avoid cloning values into the callbacks, but changing these types to all be <tt>Clone</tt> and store static-lifetime callbacks was worth making the code far more maintainable.</p>
</div>
<h4>Threading and Thread Safety</h4>
<p>The careful reader might remember that we discussed how our threading model involves interacting with the UI implementations&nbsp;<em>only</em> on the main thread. This includes updating the data bindings, since the UI implementations might have registered callbacks on them! While we <i>could</i> run everything in the main thread, it’s generally a much better experience to do as much off of the UI thread as possible, even if we don’t do much that’s blocking (though we will be blocking when we send crash reports). We want our business logic to default to being off of the main thread so that the UI doesn’t ever freeze. We can guarantee this with some careful design.</p>
<p>The simplest way to guarantee this behavior is to put all of the business logic in one (non-<tt>Clone</tt>, non-<tt>Sync</tt>) type (let’s call it <tt>Logic</tt>) and construct the UI and UI state (like <tt>Property</tt> values) in another type (let’s call it <tt>UI</tt>). We can then <i>move</i> the <tt>Logic</tt> value into a separate thread to guarantee that <tt>UI</tt> can’t interact with <tt>Logic</tt> directly, and vice versa. Of course we do need to communicate sometimes! But we want to ensure that this communication will always be delegated to the thread which owns the values (rather than the values directly interacting with each other).</p>
<p>We can accomplish this by creating an enqueuing function for each type and storing that in the opposite type. Such a function will be passed boxed functions to run on the owning thread that get a reference to the owned type (e.g., <tt>Box&lt;dyn FnOnce(&amp;T) + Send + 'static&gt;</tt>). This is simple to create: for the <tt>UI</tt> thread, it is just the <tt>UI</tt> implementation’s <tt>invoke</tt> method which we briefly discussed previously. The <tt>Logic</tt> thread does nothing <i>but</i> run a loop which will get these functions and run them on the owned value (we just enqueue and pass them using an <a href="https://doc.rust-lang.org/stable/std/sync/mpsc/fn.channel.html" rel="noreferrer" target="_blank"><tt>mpsc::channel</tt></a>). Now each type can asynchronously call methods on the other with the guarantee that they’ll be run on the correct thread.</p>
<div>
<p>In a former iteration, a more complicated scheme was used with thread-local storage and a central type which was responsible for both creating threads and delegating the functions. But with such a basic use case as two threads delegating between each other, we were able to distill this to the essential aspects needed, greatly simplifying the code.</p>
</div>
<h3>Localization</h3>
<p>One nice benefit of this rewrite is that we could bring the localization of the crash reporter up to speed with our modern tooling. In almost every other part of Firefox, we use <a href="https://projectfluent.org/" rel="noreferrer" target="_blank"><tt>fluent</tt></a> to handle localization. Using <tt>fluent</tt> in the crash reporter makes the experience of localizers more uniform and predictable; they do not need to understand more than one localization system (the crash reporter was one of the last holdouts of the old system). It was very easy to use in the new code, with just a bit of extra code to extract the localization files from the Firefox installation when the crash reporter is run. In the worst case scenario where we can’t find or access these files, we have the <tt>en-US</tt> definitions directly bundled in the crash reporter binary.</p>
<h2>The UI Implementations</h2>
<p>We won’t go into much detail about the implementations, but it’s worth talking about each a bit.</p>
<h3>Linux (GTK)</h3>
<p>The GTK implementation is probably the most straightforward and succinct. We use <a href="https://github.com/rust-lang/rust-bindgen" rel="noreferrer" target="_blank"><tt>bindgen</tt></a> to generate Rust bindings to the GTK functions we need (avoiding vendoring any external crates). Then we simply call all of the corresponding GTK functions to set up the GTK widgets as described in the model (remember, the model was made to mirror some of the GTK concepts).</p>
<p>Since GTK is somewhat modern and meant to be written by humans (not automated tools like some of the other platforms), there weren’t really any pain points or unusual behaviors that needed to be addressed.</p>
<p>We have a handful of nice features to improve memory safety and correctness. <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/gtk.rs#96,105" rel="noreferrer" target="_blank">A set of traits</a> makes it easy to attach owned data to GObjects (ensuring data remains valid and is properly dropped when the GObject is destroyed), and <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/gtk.rs#177,205,228" rel="noreferrer" target="_blank">a few macros</a> set up the glue code between GTK signals and our data binding types.</p>
<h3>Windows (Win32)</h3>
<p>The Windows implementation may have been the most difficult to write, since Win32 GUIs are very rarely written nowadays and the API shows its age. We use the <a href="https://crates.io/crates/windows-sys" rel="noreferrer" target="_blank"><tt>windows-sys</tt></a> crate to access bindings to the API (which was already vendored in the codebase for many other Windows API uses). This crate is generated directly from Windows function metadata (by Microsoft), but otherwise its bindings aren’t terribly different from what <tt>bindgen</tt> might have produced (though they are likely a bit more accurate).</p>
<p>There were a number of hurdles to overcome. For one thing, the Win32 API doesn’t provide any layout primitives, so the high-level layout concepts we use (which allow graceful resize/repositioning) had to be <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/layout.rs" rel="noreferrer" target="_blank">implemented manually</a>. There’s also quite a few extra API calls just to get to a GUI that looks somewhat decent (correct window colors, font smoothing, high DPI handling, etc). Even the default font ends up being a terrible looking bitmapped font rather than the more modern system default; we needed to manually retrieve the system default and set it as the font to use, which was a bit surprising!</p>
<p>We have <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/window.rs#16,40,120" rel="noreferrer" target="_blank">a set of traits</a> to facilitate creating custom window classes and managing associated window data of class instances. We also <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/gdi.rs" rel="noreferrer" target="_blank">have</a> <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/font.rs" rel="noreferrer" target="_blank">wrapper</a> <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/windows/widestring.rs" rel="noreferrer" target="_blank">types</a> to properly manage the lifetimes of handles and perform type conversions (mainly <tt>String</tt> to null-terminated wide strings and back) as an extra layer of safety around the API.</p>
<h3>macOS (Cocoa/AppKit)</h3>
<p>The macOS implementation had its tricky parts, as overwhelmingly macOS GUIs are written with XCode and there’s a lot of automated and generated portions (such as nibs). We again use <a href="https://github.com/rust-lang/rust-bindgen" rel="noreferrer" target="_blank"><tt>bindgen</tt></a> to generate Rust bindings, this time for the Objective-C APIs in macOS framework headers.</p>
<p>Unlike Windows and GTK, you don’t get keyboard shortcuts like Cmd-C, Cmd-Q, etc, for free if creating a GUI without e.g. XCode (which generates it for you as part of a new project template). To have these typical shortcuts that users expect, we needed to manually implement the application main menu (which is what governs keyboard shortcuts). We also had to handle runtime setup like creating Objective-C autorelease pools, bringing the window <i>and application</i> (which are separate concepts) to the foreground, etc. Even implementing <tt>invoke</tt> to call a function on the main thread had its nuances, since modal windows use a nested event loop which would not call queued functions under the default <tt>NSRunLoop</tt> mode.</p>
<p>We wrote some <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/macos/objc.rs" rel="noreferrer" target="_blank">simple helper types and a macro</a> to make it easy to implement, register, and create Objective-C classes from Rust code. We used this for creating delegate classes as well as subclassing some controls for the implementation (like <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/ui/macos/mod.rs#365-386" rel="noreferrer" target="_blank"><tt>NSButton</tt></a>); it made it easy to safely manage the memory of Rust values underlying the classes and correctly register class method selectors.</p>
<h3>The Test UI</h3>
<p>We’ll discuss testing in the next section. Our testing UI is very simple. It <i>doesn’t</i> create a GUI, but allows us to interact directly with the model. The <tt>ui!</tt> macro supports an extra piece of syntax when tests are enabled to optionally set a string identifier for each element. We use these strings in unit tests to access and interact with the UI. The data binding types also support a few additional methods in tests to easily manipulate values. This UI allows us to simulate button presses, field entry, etc, to ensure that other UI state changes as expected as well as simulating the system side effects.</p>
<h2>Mocking and Testing</h2>
<p>An important goal of our rewrite was to add tests to the crash reporter; our old code was sorely lacking them (in part because unit testing GUIs is notoriously difficult).</p>
<h3>Mocking Everything</h3>
<p>In the new code, we can mock the crash reporter regardless of whether we are running tests or not (though it is always mocked for tests). This is important because mocking allows us to (manually) run the GUI in various states to check that the GUI implementations are correct and render well. Our mocking not only mocks the inputs to the crash reporter (environment variables, command line parameters, etc), it also mocks <i>all</i> side-effectful std functions.</p>
<p>We accomplish this by having a <tt>std</tt> module in the crate, and using <tt>crate::std</tt> throughout the rest of the code. When mocking is disabled, <tt>crate::std</tt> is simply the same as <tt>::std</tt>. But when it is enabled, a bunch of functions that we have written are used instead. These mock the filesystem, environment, launching external commands, and other side effects. Importantly, only the minimal amount to mock the existing functions is implemented, so that if e.g. some new functions from <tt>std::fs</tt>, <tt>std::net</tt>, etc. are used, the crate will fail to compile with mocking enabled (so that we don’t <i>miss</i> any side effects). This might sound like a lot of effort, but you might be surprised at how little of <tt>std</tt> really needed to be mocked, and most implementations were pretty straightforward.</p>
<p>Now that we have our code using different mocked functions, we need to have a way of injecting the desired mock data (both in tests and in our normal mocked operation). For example, we have the ability to return some data when a <tt>File</tt> is read, but we need to be able to set that data differently for tests. Without going into too much detail, we accomplish this using a thread-local store of mock data. This way, we don’t need to change any code to accommodate the mock data; we only need to make changes where we set and retrieve it. The programming language enthusiasts out there may recognize this as a form of <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scope" rel="noreferrer" target="_blank">dynamic scoping</a>. The <a href="https://searchfox.org/mozilla-central/rev/47a0a01e1f7ad0451c6ba6c790d5c6855df512c1/toolkit/crashreporter/client/app/src/std/mock.rs" rel="noreferrer" target="_blank">implementation</a> allows our mock data to be set with code like</p>
<pre><code class="language-rust">mock::builder()
    .set(
        crate::std::env::MockCurrentExe,
        "work_dir/crashreporter".into(),
    )
    .run(|| crash_reporter_main())
</code></pre>
<p>in tests, and</p>
<pre><code class="language-rust">pub fn current_exe() -&gt; std::io::Result {
    Ok(MockCurrentExe.get(|r| r.clone()))
}
</code></pre>
<p>in our <tt>crate::std::env</tt> implementation.</p>
<h3>Testing</h3>
<p>With our mocking setup and test UI, we are able to extensively test the behavior of the crash reporter. The “last mile” of this testing which we can’t automate easily is whether each UI implementation faithfully represents the UI model. We manually test this with a mocked GUI for each platform.</p>
<p>Besides that, we are able to automatically test how arbitrary UI interactions cause the crash reporter to affect its own UI state and the environment (checking which programs are invoked and network connections are made, what happens if they fail, succeed, or timeout, etc). We also set up a mock filesystem and add assertions in various scenarios over the precise resulting filesystem state once the crash reporter completes. This greatly increases our confidence in the current behaviors and ensures that future changes will not alter them, which is of the utmost importance for such an essential component of our crash reporting pipeline.</p>
<h2>The End Product</h2>
<p>Of course we can’t get away with writing all of this without a picture of the crash reporter! This is what it looks like on Linux using GTK. The other GUI implementations look the same but styled with a native look and feel.</p>
<p></p>
<p>Note that, for now, we wanted to keep it looking exactly the same as it previously did. So if you are unfortunate enough to see it, it shouldn’t appear as if anything has changed!</p>
<p>With a new, cleaned up crash reporter, we can finally unblock a number of feature requests and bug reports, such as:</p>
<ul>
<li aria-level="1"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1821414" rel="noreferrer" target="_blank">detecting whether an installation is corrupt and telling the user to re-install Firefox</a>,</li>
<li aria-level="1"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1565033" rel="noreferrer" target="_blank">checking whether there is faulty memory hardware on the crashing system</a>, and</li>
<li aria-level="1"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1866863" rel="noreferrer" target="_blank">using the Firefox network stack for the first attempt at submitting crashes (which respects user network settings like proxies)</a>.</li>
</ul>
<p>We are excited to iterate and improve further on crash reporter functionality. But ultimately it’d be wonderful if you never see or use it, and we are constantly working toward that goal!</p>
<p>The post <a href="https://hacks.mozilla.org/2024/04/porting-a-cross-platform-gui-application-to-rust/" rel="noreferrer" target="_blank">Porting a cross-platform GUI application to Rust</a> appeared first on <a href="https://hacks.mozilla.org" rel="noreferrer" target="_blank">Mozilla Hacks - the Web developer blog</a>.</p>
<p></p></div>
		<div class="content-meta">
			<time datetime=2024-04-23T19:08:08.000Z>23 April 2024</time>
			<a href="/urls/hacks-mozilla-org-feed">hacks.mozilla.org/feed/</a>
			<div> <a href="/tags/web-platform.html">web-platform</a> |  <a style="font-weight: bold" href="/tags/source.html">source</a></div>
		</div>
	</main>
		<footer>
			<nav>
				<a href="/">Home</a>
				<a href="/tags">Tags</a>
				<a href="/urls">URLs</a>
				<a rel="noreferrer" target="_blank" href="https://github.com/thoughtsunificator/rss-feed-static-generator">Source code</a>
			</nav>
		</footer>
		<script src="/highlight.min.js"></script>
		<script>hljs.highlightAll();</script>
		</body>
</html>