<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Prevent, to some degree, the execution of inline JavaScript, as well as blocking all plugin content  -->
		<meta http-equiv="Content-Security-Policy" content="script-src 'none'; object-src 'none'; img-src 'none'; font-src 'none'; media-src 'none'; worker-src 'none'; connect-src 'none'; style-src 'self' ">
		<title>WebAssembly JSPI has a new API</title>
		<link rel="icon" href="favicon.png" />
		<link rel="stylesheet" href="/a11y-dark.css">
		<link rel="stylesheet" href="/style.css">
	</head>
	<body>
		<main>
		<a target="_blank" rel="noreferrer" href="https://v8.dev/blog/jspi-newapi">Go to article URL</a>
		<div id="content"><p></p><p>WebAssembly’s JavaScript Promise Integration (JSPI) API has a new API, available in Chrome release M126. We talk about what has changed, how to use it with Emscripten, and what is the roadmap for JSPI.</p>
<p>JSPI is an API that allows WebAssembly applications that use <em>sequential</em> APIs to access Web APIs that are <em>asynchronous</em>. Many Web APIs are crafted in terms of JavaScript <code>Promise</code> objects: instead of immediately performing the requested operation, they return a <code>Promise</code> to do so. On the other hand, many applications compiled to WebAssembly come from the C/C++ universe, which is dominated by APIs that block the caller until they are completed.</p>
<p>JSPI hooks into the Web architecture to allow a WebAssembly application to be suspended when the <code>Promise</code> is returned and resumed when the <code>Promise</code> is resolved.</p>
<p>You can find out more about JSPI and how to use it <a href="https://v8.dev/blog/jspi" rel="noreferrer" target="_blank">in this blog post</a> and in the <a href="https://github.com/WebAssembly/js-promise-integration" rel="noreferrer" target="_blank">specification</a>.</p>
<h2 id="what-is-new%3F" tabindex="-1">What is new? <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#what-is-new%3F" rel="noreferrer" target="_blank">#</a></h2>
<h3 id="the-end-of-suspender-objects" tabindex="-1">The end of <code>Suspender</code> objects <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#the-end-of-suspender-objects" rel="noreferrer" target="_blank">#</a></h3>
<p>In January 2024, the Stacks sub-group of the Wasm CG <a href="https://github.com/WebAssembly/meetings/blob/297ac8b5ac00e6be1fe33b1f4a146cc7481b631d/stack/2024/stack-2024-01-29.md" rel="noreferrer" target="_blank">voted</a> to amend the API for JSPI. Specifically, instead of an explicit <code>Suspender</code> object, we will use the JavaScript/WebAssembly boundary as the delimiter for determining what computations are suspended.</p>
<p>The difference is fairly small but potentially significant: when a computation is to be suspended, it is the most recent call into a wrapped WebAssembly export that determines the 'cut point' for what is suspended.</p>
<p>The implication of this is that a developer using JSPI has a little less control over that cut point. On the other hand, not having to explicitly manage <code>Suspender</code> objects makes the API significantly easier to use.</p>
<h3 id="no-more-webassembly.function" tabindex="-1">No more <code>WebAssembly.Function</code> <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#no-more-webassembly.function" rel="noreferrer" target="_blank">#</a></h3>
<p>Another change is to the style of the API. Instead of characterizing JSPI wrappers in terms of the <code>WebAssembly.Function</code> constructor, we provide specific functions and constructors.</p>
<p>This has a number of benefits:</p>
<ul>
<li>It removes dependency on the <a href="https://github.com/WebAssembly/js-types" rel="noreferrer" target="_blank"><em>Type Reflection</em> Proposal</a>.</li>
<li>It makes tooling for JSPI simpler: the new API functions no longer need to refer explicitly to the WebAssembly types of functions.</li>
</ul>
<p>This change is enabled by the decision to no longer have explicitly referenced <code>Suspender</code> objects.</p>
<h3 id="returning-without-suspending" tabindex="-1">Returning without suspending <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#returning-without-suspending" rel="noreferrer" target="_blank">#</a></h3>
<p>A third change refers to the behavior of suspending calls. Instead of always suspending when calling a JavaScript function from a suspending import, we only suspend when the JavaScript function actually returns a <code>Promise</code>.</p>
<p>This change, while apparently going against the <a href="https://www.w3.org/2001/tag/doc/promises-guide#accepting-promises" rel="noreferrer" target="_blank">recommendations</a> of the W3C TAG, represents a safe optimization for JSPI users. It is safe because JSPI is actually taking on the role of a <em>caller</em> to a function that returns a <code>Promise</code>.</p>
<p>This change will likely have minimal impact on most applications; however, some applications will see a notable benefit by avoiding unnecessary trips to the browser's event loop.</p>
<h3 id="the-new-api" tabindex="-1">The new API <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#the-new-api" rel="noreferrer" target="_blank">#</a></h3>
<p>The API is straightforward: there is a function that takes a function exported from a WebAssembly module and converts it into a function that returns a <code>Promise</code>:</p>
<pre class="language-js"><code class="language-js">Function Webassembly<span class="token punctuation">.</span><span class="token function">promising</span><span class="token punctuation">(</span>Function wsFun<span class="token punctuation">)</span></code></pre>
<p>Note that even if the argument is typed as a JavaScript <code>Function</code>, it is actually restricted to WebAssembly functions.</p>
<p>On the suspending side, there's a new class <code>WebAssembly.Suspending</code>, together with a constructor that takes a JavaScript function as an argument. In WebIDL, this is written as follows:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">interface</span> <span class="token class-name">Suspending</span><span class="token punctuation">{</span><br>  <span class="token function">constructor</span> <span class="token punctuation">(</span>Function fun<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Note that this API has an asymmetric feel to it: there's have a function that takes a WebAssembly function and returns a new promising (<em>sic</em>) function; whereas to mark a suspending function, you enclose it in a <code>Suspending</code> object. This reflects a deeper reality about what is happening under the hood.</p>
<p>The suspending behavior of an import is intrinsically part of the <em>call</em> to the import: i.e., some function inside the instantiated module calls the import and suspends as a result.</p>
<p>On the other hand, the <code>promising</code> function takes a regular WebAssembly function and returns a new one that can respond to being suspended and which returns a <code>Promise</code>.</p>
<h3 id="using-the-new-api" tabindex="-1">Using the new API <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#using-the-new-api" rel="noreferrer" target="_blank">#</a></h3>
<p>If you are an Emscripten user, then using the new API will typically involve no changes to your code. You must be using a version of Emscripten that is at least 3.1.61, and you must be using a version of Chrome that is at least 126.0.6478.17 (Chrome M126).</p>
<p>If you are rolling your own integration, then your code should be significantly simpler. In particular, it is no longer necessary to have code that stores the passed-in <code>Suspender</code> object (and retrieve it when calling the import). You can simply use regular sequential code within the WebAssembly module.</p>
<h3 id="the-old-api" tabindex="-1">The old API <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#the-old-api" rel="noreferrer" target="_blank">#</a></h3>
<p>The old API will continue to operate at least until October 29, 2024 (Chrome M128). After that, we plan on removing the old API.</p>
<p>Note that Emscripten itself will no longer support the old API as of version 3.1.61.</p>
<h3 id="detecting-which-api-is-in-your-browser" tabindex="-1">Detecting which API is in your browser <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#detecting-which-api-is-in-your-browser" rel="noreferrer" target="_blank">#</a></h3>
<p>Changing APIs should never be taken lightly. We are able to do so in this case because JSPI itself is still provisional. There is a simple way that you can test to see which API is enabled in your browser:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">oldAPI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">return</span> WebAssembly<span class="token punctuation">.</span>Suspender<span class="token operator">!=</span><span class="token keyword">undefined</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">newAPI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">return</span> WebAssembly<span class="token punctuation">.</span>Suspending<span class="token operator">!=</span><span class="token keyword">undefined</span><br><span class="token punctuation">}</span></code></pre>
<p>The <code>oldAPI</code> function returns true if the old JSPI API is enabled in your browser, and the <code>newAPI</code> function returns true if the new JSPI API is enabled.</p>
<h2 id="what-is-happening-with-jspi%3F" tabindex="-1">What is happening with JSPI? <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#what-is-happening-with-jspi%3F" rel="noreferrer" target="_blank">#</a></h2>
<h3 id="implementation-aspects" tabindex="-1">Implementation aspects <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#implementation-aspects" rel="noreferrer" target="_blank">#</a></h3>
<p>The biggest change to JSPI that we are working on is actually invisible to most programmers: so-called growable stacks.</p>
<p>The current implementation of JSPI is based on allocating stacks of a fixed size. In fact, the allocated stacks are rather large. This is because we have to be able to accommodate arbitrary WebAssembly computations which may require deep stacks to handle recursion properly.</p>
<p>However, this is not a sustainable strategy: we would like to support applications with millions of suspended coroutines; this is not possible if each stack is 1MB in size.</p>
<p>Growable stacks refers to a stack allocation strategy that allows a WebAssembly stack to grow as needed. That way, we can start with very small stacks for those applications that only need small stack space, and grow the stack when the application runs out of space (otherwise known as stack overflow).</p>
<p>There are several potential techniques for implementing growable stacks. One that we are investigating is segmented stacks. A segmented stack consists of a chain of stack regions — each of which has a fixed size, but different segments may have different sizes.</p>
<p>Note that while we may be solving the stack overflow issue for coroutines, we are not planning to make the main or central stack growable. Thus, if your application runs out of stack space, growable stacks will not fix your problem unless you use JSPI.</p>
<h3 id="the-standards-process" tabindex="-1">The standards process <a class="bookmark" href="https://v8.dev/blog/jspi-newapi#the-standards-process" rel="noreferrer" target="_blank">#</a></h3>
<p>As of publication, there is an active <a href="https://v8.dev/blog/jspi-ot" rel="noreferrer" target="_blank">origin trial for JSPI</a>. The new API will be live during the remainder of the origin trial — available with Chrome M126.</p>
<p>The previous API will also be available during the origin trial; however, it is planned to be retired shortly after Chrome M128.</p>
<p>After that, the main thrust for JSPI revolves around the standardization process. JSPI is currently (at publication time) in phase 3 of the W3C Wasm CG process. The next step, i.e., moving to phase 4, marks the crucial adoption of JSPI as a standard API for the JavaScript and WebAssembly ecosystems.</p>
<p>We would like to know what you think about these changes to JSPI! Join the discussion at the <a href="https://github.com/WebAssembly/js-promise-integration" rel="noreferrer" target="_blank">W3C WebAssembly Community Group repo</a>.</p>
<p></p></div>
		<div class="content-meta">
			<time datetime=2024-06-04T00:00:00.000Z>4 June 2024</time>
			<a href="/urls/v8-dev-blog-atom">v8.dev/blog.atom</a>
			<div> <a href="/tags/javascript.html">javascript</a> |  <a style="font-weight: bold" href="/tags/source.html">source</a></div>
		</div>
	</main>
		<footer>
			<nav>
				<a href="/">Home</a>
				<a href="/tags">Tags</a>
				<a href="/urls">URLs</a>
				<a rel="noreferrer" target="_blank" href="https://github.com/thoughtsunificator/rss-feed-static-generator">Source code</a>
			</nav>
		</footer>
		<script src="/highlight.min.js"></script>
		<script>hljs.highlightAll();</script>
		</body>
</html>