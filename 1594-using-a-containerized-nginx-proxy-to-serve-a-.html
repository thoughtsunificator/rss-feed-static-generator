<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Prevent, to some degree, the execution of inline JavaScript, as well as blocking all plugin content  -->
		<meta http-equiv="Content-Security-Policy" content="script-src 'none'; object-src 'none'; img-src 'none'; font-src 'none'; media-src 'none'; worker-src 'none'; connect-src 'none'; style-src 'self' ">
		<title>Using a Containerized Nginx Proxy to Serve a Multi-Application .NET System</title>
		<link rel="icon" href="favicon.png" />
		<link rel="stylesheet" href="/a11y-dark.css">
		<link rel="stylesheet" href="/style.css">
	</head>
	<body>
		<main>
		<a target="_blank" rel="noreferrer" href="https://www.endpointdev.com/blog/2024/09/using-a-containerized-nginx-proxy-to-serve-a-multi-application-dotnet-system/">Go to article URL</a>
		<div id="content"><p></p>
        <p></p>
<!-- Photo by Seth Jensen -->
<p>We recently <a href="/blog/2024/07/using-docker-compose-to-deploy-a-multi-application-dotnet-system/" rel="noreferrer" target="_blank">blogged</a> about how we deployed a system made of multiple .NET applications using <a href="https://www.docker.com/resources/what-container/" rel="noreferrer" target="_blank">Docker containers</a>. In order to make them accessible over the internet, we created a <a href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="noreferrer" target="_blank">reverse proxy</a> using <a href="https://nginx.org/en/" rel="noreferrer" target="_blank">Nginx</a>.</p>
<p>In that case, we installed and configured the Nginx instance directly in the server, as opposed to the rest of the applications, which ran within containers. That approach did and still does work well for us.</p>
<p>In this article, we’re going to explore an alternative strategy. One where we push the containerization aspect further and deploy and run the Nginx instance itself in a Docker container.</p>
<h3 id="reintroducing-the-demo-project">Reintroducing the demo project</h3>
<p>Like I said, our system has multiple runtime components, each one of them running in their own container. We have two ASP.NET Core web applications: an Admin Portal and a Web API. They live in <a href="https://github.com/megakevin/end-point-blog-dotnet-8-demo" rel="noreferrer" target="_blank">this Git repository</a>. And we also have a <a href="https://www.postgresql.org/" rel="noreferrer" target="_blank">Postgres</a> database, which the apps interact with.</p>
<p>We also have <a href="https://github.com/megakevin/end-point-blog-dotnet-docker-deploy" rel="noreferrer" target="_blank">another repository</a> where the deployment-related files are stored. Among others, there are the expected <code>compose.yaml</code> and <code>Dockerfile</code>s that describe the entire infrastructure.</p>
<p>Throughout this post we will update those deployment configuration files to add an Nginx reverse proxy.</p>
<p>Let’s see what that would look like.</p>
<h3 id="adding-the-proxy-service-in-composeyaml">Adding the proxy service in <code>compose.yaml</code></h3>
<p>First we need to add the new container in the <code>compose.yaml</code>’s <code>services</code> section. It doesn’t need to be too complicated:</p>
<div class="highlight"><pre tabindex="0"><code class="language-yaml" data-lang="yaml"><span><span><span># compose.yaml</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>services</span>:<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span># ...</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>proxy</span>:<span>
</span></span></span><span><span><span>    </span><span># The proxy container will be based on this Dockerfile, which we'll define</span><span>
</span></span></span><span><span><span>    </span><span># soon.</span><span>
</span></span></span><span><span><span>    </span><span>build</span>:<span>
</span></span></span><span><span><span>      </span><span>context</span>:<span> </span>.<span>
</span></span></span><span><span><span>      </span><span>dockerfile</span>:<span> </span>Dockerfile.Proxy<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span># Here we expose the Nginx proxy via port 8888. This can be anything. In</span><span>
</span></span></span><span><span><span>    </span><span># fact, if you want to do multiple parallel deployments on the same machine,</span><span>
</span></span></span><span><span><span>    </span><span># that is, with many Nginx instances running at the same time, you can</span><span>
</span></span></span><span><span><span>    </span><span># adjust this setting appropriately to prevent port conflicts. Making sure</span><span>
</span></span></span><span><span><span>    </span><span># that each instance has its own port.</span><span>
</span></span></span><span><span><span>    </span><span>ports</span>:<span>
</span></span></span><span><span><span>      </span>- <span>8888</span>:<span>80</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span># We want the proxy to start up after the admin-portal and web-api services</span><span>
</span></span></span><span><span><span>    </span><span># are up and running. The depends_on setting helps with that.</span><span>
</span></span></span><span><span><span>    </span><span>depends_on</span>:<span>
</span></span></span><span><span><span>      </span><span>admin-portal</span>:<span>
</span></span></span><span><span><span>        </span><span>condition</span>:<span> </span>service_started<span>
</span></span></span><span><span><span>      </span><span>web-api</span>:<span>
</span></span></span><span><span><span>        </span><span>condition</span>:<span> </span>service_started<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#...</span><span>
</span></span></span></code></pre></div><h3 id="writing-the-proxy-dockerfile">Writing the proxy <code>Dockerfile</code></h3>
<p>As you saw, the <code>proxy</code> configuration in <code>compose.yaml</code> leverages an external <code>Dockerfile</code> to build the container image that will run our Nginx proxy. This file is also very straightforward. It uses <a href="https://hub.docker.com/_/nginx" rel="noreferrer" target="_blank">the official Nginx image from Docker Hub</a> and it looks like this:</p>
<div class="highlight"><pre tabindex="0"><code class="language-dockerfile" data-lang="dockerfile"><span><span><span># Dockerfile.Proxy</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span># We can pick the version and flavor that we like. In our case here, this is an</span><span>
</span></span></span><span><span><span></span><span># image based on the latest release of Nginx, and the latest release of Debian.</span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> nginx:1.27.1-bookworm</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span># Unsurprisingly, we have a custom configuration that we want the proxy to use.</span><span>
</span></span></span><span><span><span></span><span># This is how we make sure it does. We copy it into the default location inside</span><span>
</span></span></span><span><span><span></span><span># the image.</span><span>
</span></span></span><span><span><span></span><span>COPY</span> proxy/nginx.conf /etc/nginx/nginx.conf<span>
</span></span></span></code></pre></div><h3 id="configuring-the-proxy">Configuring the proxy</h3>
<p>Now we have to configure the Nginx proxy to route requests to both our web applications. Here’s an <code>nginx.conf</code> that does just that:</p>
<div class="highlight"><pre tabindex="0"><code class="language-plain" data-lang="plain"><span><span># proxy/nginx.conf
</span></span><span><span>
</span></span><span><span>user  nginx;
</span></span><span><span>worker_processes  auto;
</span></span><span><span>
</span></span><span><span>error_log  /var/log/nginx/error.log notice;
</span></span><span><span>pid        /var/run/nginx.pid;
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>events {
</span></span><span><span>    worker_connections  1024;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>http {
</span></span><span><span>    include       /etc/nginx/mime.types;
</span></span><span><span>    default_type  application/octet-stream;
</span></span><span><span>
</span></span><span><span>    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
</span></span><span><span>                      '$status $body_bytes_sent "$http_referer" '
</span></span><span><span>                      '"$http_user_agent" "$http_x_forwarded_for"';
</span></span><span><span>
</span></span><span><span>    access_log  /var/log/nginx/access.log  main;
</span></span><span><span>
</span></span><span><span>    sendfile        on;
</span></span><span><span>
</span></span><span><span>    keepalive_timeout  65;
</span></span><span><span>
</span></span><span><span>    # We have to comment out or remove this line to make sure the default
</span></span><span><span>    # configuration that comes in the official image is not applied.
</span></span><span><span>    # include /etc/nginx/conf.d/*.conf;
</span></span><span><span>
</span></span><span><span>    # Our customizations start here:
</span></span><span><span>    server {
</span></span><span><span>        # With this listen directive, we configure our proxy to expect
</span></span><span><span>        # connections coming from the default HTTP port: 80.
</span></span><span><span>        listen 80;
</span></span><span><span>
</span></span><span><span>        # This location directive makes sure all requests coming to URLs that
</span></span><span><span>        # look like .../admin are routed to the Admin Portal web app.
</span></span><span><span>        location ~ ^/admin(/?)(.*) {
</span></span><span><span>            proxy_pass http://admin-portal:8080;
</span></span><span><span>            proxy_http_version 1.1;
</span></span><span><span>            proxy_set_header Host $host;
</span></span><span><span>            proxy_set_header Connection keep-alive;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        # This location directive makes sure all requests coming to URLs that
</span></span><span><span>        # look like .../api are routed to the Web API.
</span></span><span><span>        location ~ ^/api(/?)(.*) {
</span></span><span><span>            proxy_pass http://web-api:8080;
</span></span><span><span>            proxy_http_version 1.1;
</span></span><span><span>            proxy_set_header Host $host;
</span></span><span><span>            proxy_set_header Connection keep-alive;
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>What I’ve done here is take the default Nginx configuration file that comes right out of the box, and replace the <code>include /etc/nginx/conf.d/*.conf;</code> line with my own <code>server</code> block directive.</p>
<blockquote>
<p>As explained in <a href="https://hub.docker.com/_/nginx" rel="noreferrer" target="_blank">the official image’s Docker Hub page</a>, a quick way of obtaining a copy of this default file is using this command: <code>docker run --rm --entrypoint=cat nginx /etc/nginx/nginx.conf &gt; /host/path/nginx.conf</code>.</p>
</blockquote>
<p>The most interesting parts are the <code>proxy_pass</code> directives that take care of redirecting traffic to the apps. Notice how they refer to the Admin Portal using <code>http://admin-portal:8080</code> and to the Web API by <code>http://web-api:8080</code>. These are the internal naming of these components within the containers’ virtual network, which gets created automatically by Docker Compose.</p>
<p>Remember that this Nginx instance is not running in the host machine directly. Instead it’s running in a container. In the same virtual network as the other containers described in <code>compose.yaml</code>. That’s why it has to use the hostnames assigned by <code>compose.yaml</code> (i.e. <code>admin-portal</code> and <code>web-api</code>) and the port through which the ASP.NET Core apps running within accept requests (i.e. <code>8080</code>).</p>
<p>This is the idea:</p>
<p></p>
<p>It also uses <code>proxy_set_header</code> directives to set <code>Host</code> and <code>Connection</code> headers. This is typical practice when it comes to Nginx reverse proxies. You can read more about that <a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/#passing-request-headers" rel="noreferrer" target="_blank">on Nginx’s website</a>.</p>
<h3 id="configuring-the-pathbase-in-aspnet-core-apps">Configuring the PathBase in ASP.NET Core apps</h3>
<p>There’s an additional step that we have to take to make all this work. We have configured our Nginx proxy to serve both applications under the same “server”, and rely on different URL paths (i.e. <code>/admin</code> vs <code>/api</code>) to determine which app will receive which request. This means that we have to perform further configuration in the apps so that routing is done properly. Thankfully, all it takes is a one-liner in each of the apps’ <code>Program.cs</code> files. After the usual <code>var app = builder.Build();</code> line, we do the following:</p>
<p>For the Admin Portal, we add this:</p>
<div class="highlight"><pre tabindex="0"><code class="language-csharp" data-lang="csharp"><span><span><span>// source/VehicleQuotes.AdminPortal/Program.cs</span>
</span></span><span><span>
</span></span><span><span><span>// ...</span>
</span></span><span><span>
</span></span><span><span>app.UsePathBase(<span>"/admin"</span>);
</span></span><span><span>
</span></span><span><span><span>// ...</span>
</span></span></code></pre></div><p>And for the Web API:</p>
<div class="highlight"><pre tabindex="0"><code class="language-csharp" data-lang="csharp"><span><span><span>// source/VehicleQuotes.WebApi/Program.cs</span>
</span></span><span><span>
</span></span><span><span><span>// ...</span>
</span></span><span><span>
</span></span><span><span>app.UsePathBase(<span>"/api"</span>);
</span></span><span><span>
</span></span><span><span><span>// ...</span>
</span></span></code></pre></div><p>With that, the apps are ready to handle requests coming from the Nginx proxy, which will include either the <code>/admin</code> or <code>/api</code> sections.</p>
<h3 id="deploying">Deploying</h3>
<p>Finally, we can deploy. Go into the directory where all the deployment configuration files live. That’s the one with the <code>compose.yaml</code> file. In other words, the root of <a href="https://github.com/megakevin/end-point-blog-dotnet-docker-deploy" rel="noreferrer" target="_blank">the deploy repo</a>. Once in there, run:</p>
<div class="highlight"><pre tabindex="0"><code class="language-plain" data-lang="plain"><span><span>docker compose up --build
</span></span></code></pre></div><p>After a while, Docker compose will have built and deployed everything for us. Now you can navigate to the apps in any browser at http://localhost:8888/admin and http://localhost:8888/api/swagger/index.html.</p>
<p></p>
<p></p>
<p>As you click around, you can see the Nginx logs with:</p>
<div class="highlight"><pre tabindex="0"><code class="language-plain" data-lang="plain"><span><span>docker compose logs proxy -f
</span></span></code></pre></div><p></p>
<p>To bring it all back down, you can run:</p>
<div class="highlight"><pre tabindex="0"><code class="language-plain" data-lang="plain"><span><span>docker compose down
</span></span></code></pre></div><p>Cool! At the end of the day, Nginx is just another program that runs as a process in an operating system. And as such, it can be run in a container. One of the nice aspects about this setup is the convenience of having an entire system described in a set of files, and being able to bring everything up with a single command.</p>

      <p></p></div>
		<div class="content-meta">
			<time datetime=2024-09-24T00:00:00.000Z>24 September 2024</time>
			<a href="/urls/www-endpointdev-com-blog-feed-xml">www.endpointdev.com/blog/feed.xml</a>
			<div> <a href="/tags/programming.html">programming</a> |  <a href="/tags/reporting.html">reporting</a></div>
		</div>
	</main>
		<footer>
			<nav>
				<a href="/">Home</a>
				<a href="/tags">Tags</a>
				<a href="/urls">URLs</a>
				<a rel="noreferrer" target="_blank" href="https://github.com/thoughtsunificator/rss-feed-static-generator">Source code</a>
			</nav>
		</footer>
		<script src="/highlight.min.js"></script>
		<script>hljs.highlightAll();</script>
		</body>
</html>