<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Prevent, to some degree, the execution of inline JavaScript, as well as blocking all plugin content  -->
		<meta http-equiv="Content-Security-Policy" content="script-src 'none'; object-src 'none'; img-src 'none'; font-src 'none'; media-src 'none'; worker-src 'none'; connect-src 'none'; style-src 'self' ">
		<title>Writing a WebSocket-Controlled State Machine</title>
		<link rel="icon" href="favicon.png" />
		<link rel="stylesheet" href="/a11y-dark.css">
		<link rel="stylesheet" href="/style.css">
	</head>
	<body>
		<main>
		<a target="_blank" rel="noreferrer" href="https://www.endpointdev.com/blog/2024/07/websocket-controlled-state-machine/">Go to article URL</a>
		<div id="content"><p></p>
        <p></p>
<!-- Photo by Seth Jensen, 2024. -->
<p><em>This article was co-authored by <a href="/team/jacob-minshall/" rel="noreferrer" target="_blank">Jacob Minshall</a></em></p>
<p>We recently developed a state machine to control a piece of software for a client. The client wanted to have an API to interact with the state machine, triggering state changes while it was running. Depending on the current state’s requirements, the state machine could either wait for a WebSocket message to proceed to another state or transition to the next state without outside input. WebSockets allow for two way communication so the clients can also have visibility into the state machine’s current state.</p>
<p>To start, we looked for a simple way to implement a state machine within our TypeScript/Node.js based project. The <a href="https://github.com/eram/typescript-fsm" rel="noreferrer" target="_blank"><code>typescript-fsm</code></a> library on GitHub was a good solution for us. What made us consider this package was the simplicity of the library: the entire source file is around 100 lines of code.</p>
<p>We did end up making some custom changes to the library that won’t be shown here; for example, we wanted to broadcast state change messages via WebSockets to any connected clients. With such a simple library, it was a breeze adding that code. The code in this post will still run with the vanilla library, it just won’t notify you when the state changes.</p>
<p>Here’s a simple example of a state machine that manages a car’s door (borrowed from the <code>typescript-fsm</code> README, with some modifications). It can be opened or closed, but it can also be in the middle of opening and closing as well. If the door is closed, you can’t close it again. If it’s opening, then trying to close it will have to wait until the door has finished opening.</p>
<p>As a side note, state machines lend themselves well to diagrams. These help developers and clients see and understand the code at a high level. PlantUML has worked well for us. Our door diagram is below:</p>
<p></p>
<p>Let’s break down the door state machine first, then the WebSocket control after.</p>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span><span>// Use our customized version of typescript-fsm
</span></span></span><span><span><span></span><span>import</span> { t, StateMachine } <span>from</span> <span>"./stateMachine"</span>;
</span></span><span><span>
</span></span><span><span><span>enum</span> States { closing = <span>0</span>, closed, opening, opened, broken };
</span></span><span><span><span>enum</span> Events { open = <span>100</span>, openComplete, close, closeComplete, <span>break</span> };
</span></span></code></pre></div><p>We start by creating the basic states and events. These are each just enums that will be used when checking the current state and moving from one state to the next.</p>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span><span>// lets define the transitions that will govern the state-machine
</span></span></span><span><span><span></span><span>const</span> transitions = [
</span></span><span><span>  <span>/* fromState        event                 toState         callback */</span>
</span></span><span><span>  t(States.closed,    Events.open,          States.opening, onOpen),
</span></span><span><span>  t(States.opening,   Events.openComplete,  States.opened,  justLog),
</span></span><span><span>  t(States.opened,    Events.close,         States.closing, onClose),
</span></span><span><span>  t(States.closing,   Events.closeComplete, States.closed,  justLog),
</span></span><span><span>];
</span></span></code></pre></div><p>Here the transitions are defined. This is a list of tuples that define the state machine. First is the starting state where an event can occur. Next is the events that will cause a state transition to happen, and then the state that will be transitioned to. Finally there’s the callback that is called as part of the transition. It’s not shown here, but one state may have multiple transitions, for instance if you wanted the closed state could have an event called “lock” that moves to the state locked, that way while in the closed state you the door would respond to either the “open” event or the “lock” event.</p>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span><span>// initialize the state machine
</span></span></span><span><span><span></span><span>const</span> door = <span>new</span> StateMachine&lt;<span>States</span><span>,</span> <span>Events</span>&gt;(
</span></span><span><span>   States.closed,   <span>// initial state
</span></span></span><span><span><span></span>   transitions,     <span>// array of transitions 
</span></span></span><span><span><span></span>);
</span></span></code></pre></div><p>This is how the state machine itself is created. The enums are passed to the machine so it knows what states and events there are, then the transitions and starting state are supplied to the constructor, and the new state machine is returned. Multiple doors can be created; each door object would have a “dispatch” method attached to it to send the events that are happening to that specific door.</p>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span><span>// transition callbacks - async functions
</span></span></span><span><span><span></span><span>async</span> <span>function</span> onOpen() {
</span></span><span><span>    console.log(<span>"onOpen..."</span>);
</span></span><span><span>    <span>// actually open the door
</span></span></span><span><span><span></span>    
</span></span><span><span>    <span>// waiting 5 seconds and then pretending the door has been opened
</span></span></span><span><span><span></span>    setTimeout(() =&gt; {door.dispatch(Events.openComplete);}, <span>5000</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>async</span> <span>function</span> onClose() {
</span></span><span><span>    console.log(<span>"onClose..."</span>);
</span></span><span><span>    <span>// actually close the door
</span></span></span><span><span><span></span>    
</span></span><span><span>    <span>// waiting 5 seconds and then pretending the door has been closed
</span></span></span><span><span><span></span>    setTimeout(() =&gt; {door.dispatch(Events.closeComplete);}, <span>5000</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// synchronous callbacks are also ok
</span></span></span><span><span><span></span><span>function</span> justLog() { 
</span></span><span><span>    console.log(<span>`new state is: </span><span>${</span>States[door.getState()]<span>}</span><span>`</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>These are basic callbacks to use as an example. When opening or closing the door, the script will wait 5 seconds and signal a completion of either event, changing the state automatically. This means some of the state transitions are internal to the state machine rather than external. Once the door has begun opening, the user is no longer in control of when it has finished opening, they just have to wait for it to be in the opened state. A door will never start closing on its own with this implementation, so some outside source will need to initiate the closing/opening process.</p>
<blockquote>
<p>Make sure you have the <code>ws</code> package installed via NPM: <code>npm install ws</code>. You also need the <code>@types/ws</code> package for WebSocket type definitions: <code>npm i --save-dev @types/ws</code>.</p>
</blockquote>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span><span>import</span> WebSocket <span>from</span> <span>'ws'</span>;
</span></span><span><span>
</span></span><span><span>console.log(<span>"creating websocket server"</span>);
</span></span><span><span><span>let</span> ws = <span>new</span> WebSocket.Server({port: <span>9091</span>})
</span></span><span><span>
</span></span><span><span>ws.on(<span>"connection"</span>, (socket: <span>WebSocket</span>) =&gt; {
</span></span><span><span>    console.log(<span>"you are connected to the websocket"</span>);
</span></span><span><span>
</span></span><span><span>    <span>// handle a message coming in on this websocket
</span></span></span><span><span><span></span>    socket.on(<span>"message"</span>, <span>async</span> (message: <span>string</span>) =&gt; {
</span></span></code></pre></div><p>This creates the WebSocket, puts it on port 9091, and then starts to define what to do when it gets a message.</p>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span>        <span>// message is JSON
</span></span></span><span><span><span></span>        <span>let</span> msg = JSON.parse(message);
</span></span><span><span>
</span></span><span><span>        <span>// if there's an event inside the message handle it
</span></span></span><span><span><span></span>        <span>if</span> (msg.event) {
</span></span><span><span>            <span>let</span> event: <span>number</span> = msg.event;
</span></span><span><span>
</span></span><span><span>            <span>// check if the state can happen according to transitions available
</span></span></span><span><span><span></span>            <span>if</span> (door.can(event)) {
</span></span><span><span>                <span>// dispatch that event to kick off the state transition
</span></span></span><span><span><span></span>                <span>await</span> door.dispatch(event);
</span></span><span><span>                <span>// return to the websocket the current state
</span></span></span><span><span><span></span>                <span>// if open is sent, opening will be the new state
</span></span></span><span><span><span></span>                <span>// that is returned
</span></span></span><span><span><span></span>                socket.send(JSON.stringify({
</span></span><span><span>                    current_state: <span>door.getState</span>()
</span></span><span><span>                }))
</span></span></code></pre></div><p>Here the message sent by the client is parsed into JSON. If there’s an event requested, we check if the door can handle that event. This means that when the door is in the opened state and the open event is sent we won’t try to dispatch that event. The dispatch call is the way the state machine requests a state change. Internally, it also checks to see if the event is possible.</p>
<div class="highlight"><pre tabindex="0"><code class="language-typescript" data-lang="typescript"><span><span>            } <span>else</span> {
</span></span><span><span>                console.log(<span>`error, bad event sent </span><span>${</span>event<span>}</span><span>`</span>)
</span></span><span><span>                socket.send(JSON.stringify({
</span></span><span><span>                    error: <span>`bad event sent </span><span>${</span>event<span>}</span><span>`</span>,
</span></span><span><span>                    current_state: <span>door.getState</span>()
</span></span><span><span>                }))
</span></span><span><span>            }
</span></span><span><span>        } <span>else</span> <span>if</span> (msg.current_state) {
</span></span><span><span>            socket.send(JSON.stringify({
</span></span><span><span>                current_state: <span>door.getState</span>()
</span></span><span><span>            }))
</span></span><span><span>        }
</span></span><span><span>    });
</span></span><span><span>});
</span></span></code></pre></div><p>Another option in the API is a simple check of the current state. If the message sent has a field that has the key <code>current_state</code> then the current state is returned on the socket.</p>
<p>The car door example is a simple use case; the state machine that we wrote for our client has 15 different states and 36 different transitions. Adding and changing states has proven fairly easy and the states themselves provide nice ways to encapsulate fairly complicated behaviors. This encapsulation has eased the cognitive load required to work on the codebase, so we will definitely keep this in our tool bag for future projects.</p>

      <p></p></div>
		<div class="content-meta">
			<time datetime=2024-07-20T00:00:00.000Z>20 July 2024</time>
			<a href="/urls/www-endpointdev-com-blog-feed-xml">www.endpointdev.com/blog/feed.xml</a>
			<div> <a href="/tags/programming.html">programming</a> |  <a href="/tags/reporting.html">reporting</a></div>
		</div>
	</main>
		<footer>
			<nav>
				<a href="/">Home</a>
				<a href="/tags">Tags</a>
				<a href="/urls">URLs</a>
				<a rel="noreferrer" target="_blank" href="https://github.com/thoughtsunificator/rss-feed-static-generator">Source code</a>
			</nav>
		</footer>
		<script src="/highlight.min.js"></script>
		<script>hljs.highlightAll();</script>
		</body>
</html>